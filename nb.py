# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ijlUX2s3j3buzRfqtiwD0K_Zi5a9Xhvl
"""

import scipy.io
import numpy as np

def naive_bayes(trX,trY, tsX, tsY): 
  
    #calculating Priors
    rows, cols  = np.shape(trX)
    count_7 = len(trY[trY == 0.0])
    count_8 = len(trY[trY == 1.0])
    
    P_7 = count_7/rows
    P_8 = count_8/rows

    print('Let w1 denote class of digit 7 and w2 denote class of digit 8')
    
    print('Prior(w1): {:.2f}%'.format(P_7))
    print('Prior(w2): {:.2f}%'.format(P_8))

    
    #data seperation
    dataset_7 = []
    dataset_8 = []
    for i in range(len(trY[0])):
        if trY[0][i] == 0.0:
            dataset_7.append(trX[i])
        else: 
            dataset_8.append(trX[i])
    
    #feature Extraction
    features_7 = []
    for i in range(count_7):
        temp = np.array([np.mean(dataset_7[i]), np.std(dataset_7[i])])
        temp.shape = (2,1)
        features_7.append(temp)
    features_8 = []
    for i in range(count_8):
        temp = np.array([np.mean(dataset_8[i]), np.std(dataset_8[i])])
        temp.shape = (2,1)
        features_8.append(temp)
    
    mean_feature17 = np.mean([i[0][0] for i in features_7])
    mean_feature27 = np.mean([i[1][0] for i in features_7])
    
    var_feature17 = np.var([i[0][0] for i in features_7])
    var_feature27 = np.var([i[1][0] for i in features_7])
    
    mean_feature18 = np.mean([i[0][0] for i in features_8])
    mean_feature28 = np.mean([i[1][0] for i in features_8])
    
    var_feature18 = np.var([i[0][0] for i in features_8])
    var_feature28 = np.var([i[1][0] for i in features_8])
       
    mean_7 = np.array([mean_feature17, mean_feature27])
    mean_8 = np.array([mean_feature18, mean_feature28])  
    
    #data transformation  
    mean_7.shape = (2,1)
    mean_8.shape = (2,1)
    
    #coveriance matrix
    cov_7 = np.array([[var_feature17,0], [0,var_feature27]])
    cov_8 = np.array([[var_feature18,0], [0,var_feature28]])
  
    #multivariate normal probablity density function
    def multivariate_normal(x, d, mean, covariance):
        x_m = x - mean
        return (1. / (np.sqrt((2 * np.pi)**d * np.linalg.det(covariance))) * 
                    np.exp(-(np.linalg.solve(covariance, x_m).T.dot(x_m)) / 2))   
    
    # calculating accuracy
    correct7 = 0
    correct8 = 0
    total7 = list(tsY[0]).count(0.0)
    total8 = list(tsY[0]).count(1.0)        
    
    for i in range(len(tsY[0])):
        temp = np.array([np.mean(tsX[i]), np.std(tsX[i])])
        temp.shape = (2,1)
        #calculating Probablity of predicted nature of digit
        p7 = multivariate_normal(temp,2,mean_7,cov_7)*P_7
        p8 = multivariate_normal(temp,2,mean_8,cov_8)*P_8
        if (p7>p8 and tsY[0][i] == 0.0):
          correct7+=1
        if (p7<p8 and tsY[0][i] == 1.0):
          correct8 +=1
          

    print()
    print('Accuracy on Testing Data for "7": {:.2f}%'.format(100*correct7/total7))
    print('Accuracy on Testing Data for "8": {:.2f}%'.format(100*correct8/total8))    
    print('Overall Accuracy: {:.2f}%'.format((correct7+correct8)*100/(total7+total8)))
    print('********************************')

#if __name__ == "__main__":
def main():
    print('Naive Bayes Classifier')
    # data Extraction
    Numpyfile= scipy.io.loadmat('/content/mnist_data.mat')
    trX = Numpyfile['trX']
    trY = Numpyfile['trY']
    tsX = Numpyfile['tsX']
    tsY = Numpyfile['tsY']
    
    naive_bayes(trX, trY, tsX, tsY)
